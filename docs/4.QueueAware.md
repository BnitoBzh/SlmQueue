Documentation - Queue Aware
====================

It is good practice to keep jobs small and simple. Use jobs for a single task and do not create a single job for multiple
tasks. When multiple tasks should be executed, create a chain of small jobs which all are executed after each other. In
this chapter we will use example of a chain of jobs. First, a PDF file must be generated and after this the PDF must
send via email. The jobs look like this:

```php
<?php

namespace Example\Job;

use SlmQueue\Job\AbstractJob;

class PdfJob extends AbstractJob
{
    public function execute()
    {
        // Generate PDF file
    }
}

class EmailJob extends AbstractJob
{
    public function execute()
    {
        // Send the email
    }
}
```

SlmQueue solves the job chain by making the `PdfJob` responsible to start the `EmailJob`. The job to email the file is
instantiated within the pdf job. Then, it is pushed into the queue. The queue to inject the new job into can be
automatically injected by SlmQueue. In order to do this, an interface `QueueAwareInterface` must be implemented:

```php
<?php

namespace Example\Job;

use SlmQueue\Job\AbstractJob;
use SlmQueue\Queue\QueueAwareInterface;
use SlmQueue\Queue\QueueInterface;

class PdfJob extends AbstractJob implements QueueAwareInterface
{
    /**
     * {@inheritDoc}
     */
    protected $queue;

    /**
     * {@inheritDoc}
     */
    public function getQueue()
    {
        return $this->queue;
    }

    /**
     * {@inheritDoc}
     */
    public function setQueue(QueueInterface $queue)
    {
        $this->queue = $queue;
    }

    public function execute()
    {
        // Generate PDF file

        $job = new EmailJob;
        $this->getQueue()->push($job);
    }
}
```

To avoid repeating the interface methods, a trait is provided to ease writing queue aware jobs.

```php
<?php

namespace Example\Job;

use SlmQueue\Job\AbstractJob;
use SlmQueue\Queue\QueueAwareInterface;
use SlmQueue\Queue\QueueAwareTrait;

class PdfJob extends AbstractJob implements QueueAwareInterface
{
    use QueueAwareTrait;

    public function execute()
    {
        // Generate PDF file

        $job = new EmailJob;
        $this->getQueue()->push($job);
    }
}
```

Injecting dependencies into jobs
--------------------------------

In the case jobs have dependencies, the job cannot be instantiated with the `new` keyword. The job will have a factory
and the [job manager](3.Jobs.md) must be used to fetch the job from. In this case, the job manager is a second
dependency for the initiating job:

```php
<?php

namespace Example\Job;

use SlmQueue\Job\AbstractJob;
use SlmQueue\Job\JobPluginMananger;
use SlmQueue\Queue\QueueAwareInterface;
use SlmQueue\Queue\QueueAwareTrait;

use Example\Service\PdfGenerator;
use Example\Service\EmailTransport;

class PdfJob extends AbstractJob implements QueueAwareInterface
{
    use QueueAwareTrait;

    protected $generator;
    protected $jobPluginManager;

    public function __construct(PdfGenerator $generator, JobPluginMananger $jobPluginManager)
    {
        $this->generator        = $generator;
        $this->jobPluginManager = $jobPluginManager;
    }

    public function execute()
    {
        // Generate PDF file using $this->generator

        $job = $this->jobPluginManager->get('EmailJob')
        $this->getQueue()->push($job);
    }
}

class EmailJob extends AbstractJob
{
    protected $transport;

    public function __construct(EmailTransport $transport)
    {
        $this->transport = $transport;
    }

    public function execute()
    {
        // Send the email using $this->translator
    }
}
```

Navigation
----------

Previous page: [Jobs](3.Jobs.md)
Next page: [Internals](5.Internals)

1. [Introduction](1.Introduction.md)
2. [Configuration](2.Configuration.md)
3. [Jobs](3.Jobs.md)
4. [QueueAware](4.QueueAware.md)
5. [Internals](5.Internals.md)
6. [Events](6.Events.md)
7. [Worker management](7.WorkerManagement.md)
